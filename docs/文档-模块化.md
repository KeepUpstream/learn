# JavaScript模块化

​		没有模块化的编程中，通常存在几个问题：

- 必须保证script资源的加载顺序（必须先有函数|变量定义才能使用，且不说script文件还有异步加载(async)、延迟加载(defer)）
- FunctionA想要使用FunctionB的变量，需要将FunctionB的变量放到FunctionA的上层作用域
- 污染全局作用域。

​	模块，将相关变量和函数组织到一起形成所谓的模块作用域Module scope。在这个作用域中，变量和函数之间彼此可见，并且模块可以决定将自己 内部的哪些变量、类或函数设置对外可见，这个借助export实现。而模块也可以选择性的使用import使用其他模块的部分内容。

## 1. CommonJS	

​		CommonJS 的一个模块就是一个脚本文件。`Require`命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。

```json
{
  id: '...',	// 模块名
  exports: { ... },	// 模块输出的各个接口
  loaded: true, // 该模块脚本是否执行完毕
  ...
}
```

以后再执行require命令，就返回第一次运行的结果，除非手动清除系统缓存。

​		模块化方案 require/exports 是为服务器端开发设计的。服务器模块系统**同步读取模块文件内容**，编译执行后得到模块接口。Node.js是按照CommonJS规范开发的。

**【重要特性】加载时即执行。即脚本代码在`require`时就全部执行。一旦某个模块被循环加载，就只输出已经执行的部分，还未执行的部分不会输出。**		

​		在浏览器端，因为其**异步加载脚本文件**的特性，CommonJS 规范无法正常加载。所以出现了 RequireJS、SeaJS 等（兼容 CommonJS ）为浏览器设计的模块化方案。直到 ES6 规范出现，浏览器才拥有了自己的模块化方案 import/export。



## 2. AMD

​		异步模块定义（the Asynchronous Module Definition, AMD）规范声明了一套声明模块的机制用于模块及其依赖的异步加载。这很适用于浏览器环境，因为模块的同步加载会招致性能、用户体验、调试、跨域资源访问等问题。

```js
    define(id?, dependencies?, factory);
// id: 字符串，当前被定义模块的id。【可选】默认为被加载时的文件名
// dependencies: 数组，当前模块依赖的其他模块的id列表。
           // 依赖模块必须先于module factory函数被加载，加载结果按照依赖顺序被传递至factory函数。
           // 
           //【可选】默认为['require','exports','module']
// factory: 模块初始化要执行的函数或对象
```

**【典型应用】Require.js**

requirejs 在实现JavaScript模块化开发的同时，主要是解决2个问题：

  1、多个js模块相互引用问题，被依赖模块需早与依赖模块加载。

  2、js加载的会阻塞浏览器页面渲染，加载文件越多，页面失去响应时间越长 



## 3. CMD

​		其实CMD与AMD规范并没什么本质的区别，区别在于他们对依赖模块的执行时机处理不同。虽然两者都是异步加载模块，但是AMD依赖前置，js可以方便知道依赖模块是谁，要依赖什么js那就先加载进来，至于你要依赖这些js来干吗得先等着，等我加载完了资源再商量;而CMD就近依赖，需要使用这个依赖模块时，我再加载进来用。



AMD和CMD最大的区别是对依赖模块的执行时机处理不同：

    1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块
    
    2、CMD推崇就近依赖，只有在用到某个模块的时候再去require

不同点体现如下：

1、异步加载模块

    requireJS，SeaJS加载模块都是异步的，只不过AMD依赖前置，JS可以方便知道依赖模块是谁，立即加载。CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块。

2、依赖模块执行时机不同

       AMD在加载模块完成后就会执行改模块，所有依赖模块都加载执行完后会进入require的回调函数执行主逻辑，依赖模块的执行顺序和书写顺序不一定一致，主逻辑一定在所有依赖加载完成后才执行。
    
      CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。


## 4. ES Module

​		使用`export/import`命令实现。ESM有4个特性：

- 自动采用严格模式
- 每个ESM都是运行在单独的私有作用域中
- 通过CORS方式请求外部js模块
- 其script标签会延迟执行脚本



# 【参考链接】

1. AMD官网：https://github.com/amdjs/amdjs-api/blob/master/AMD.md
2. require和import的区别：https://zhuanlan.zhihu.com/p/121770261
3. ES Module语法使用：https://www.cnblogs.com/wenxuehai/p/11312851.html#_label1_1
4. ES Module特性及其使用：https://zhuanlan.zhihu.com/p/444409071
5. ES Module工作原理：https://segmentfault.com/a/1190000020388889
6. JavaScript模块的循环加载：http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html