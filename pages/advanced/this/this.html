<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<script type="text/javascript" src="./aboutThis.js" ></script>
	<title>this关键字</title>
</head>
<body>
	<h2>JavaScript <b>this</b> 关键字</h2>
	<p>方法实例中，<b>this</b> 指向了 <b>person</b> 对象。</p>
	<p>因为 person对象是fullName方法的所有者。</p>
	<p id="demo"></p>
	
	<h2>JavaScript <b>this</b> 关键字</h2>
	<p>函数实例中，<b>this</b> 指向了 window全局对象:</p>
	<p id="demo2"></p>
	<p id="demo3"></p>

	<p>实例中，<b>this</b> 表示 myFunction 函数的所有者：（或者说调用myFunction的对象）</p>
	<p id="demo4"></p>
	
	<h2>JavaScript <b>this</b> 关键字</h2>
	<p>事件中，this指向了接收事件的HTML元素</p>
	<button onclick="this.style.display='none'">点我后我就消失了</button>
		
	<h2>显式函数绑定</h2>
	<p>在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。</p>
	<p id="demo5"></p>
<script>
	//显示对象的数据
	document.getElementById("demo").innerHTML = person.fullName();
	document.getElementById("demo2").innerHTML = this;
	"use strict";
	document.getElementById("demo3").innerHTML = this;
	
	document.getElementById("demo4").innerHTML = myFunction();
function myFunction() {
  return this;
}
//call 表示传入的对象参数调用call前面对象的方法，并且被调用的函数会被执行，call方法的参数是当前上下文的对象以及参数列表
//apply也是如此，只不过它传入的参数是对象和参数数组
//bind 用法与apply|call一样，但是它被对象绑定的函数不会被执行，而是返回这个函数，需要你手动去调用返回的函数，才会返回结果。
var x = person1.fullName.call(person2); 
document.getElementById("demo5").innerHTML = x;

</script>
</body>
</html>
