/**
 * 多任务执行解决方法无非三种：
 * 排队、新建进程、新建线程。
 * JavaScript为单线程，I/O、网络SQL查询、用户交互任务只能排队进行，下一个任务需要等待上一个任务返回执行结果才能继续，这种运行模式称为“同步”或“阻塞”模式。
 * 如果批量任务同时执行或网络延迟会造成时间和资源浪费，用户体验不好
 * Event loop方案是为了协调事件、用户交互、脚本、UI渲染和网络处理等行为，防止主线程的阻塞、网页出现“假死”现象而生的
 * 他是一个程序结构，用于等待和发送和事件。
 * 简单说，就是在程序中设置两个线程：一个负责程序本身的执行，称为主线程；另一个负责主线程与其他进程的通信，称为Event Loop线程，也叫做消息线程。
 * 当遇到I/O时，主线程就会让Event Loop线程通知I/O程序，然后接着往后运行，等到I/O操作完成后，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务。
 * 
 * Event Loop包含两类：一是基于Browsing Context,二是基于Worker，二者运行相互独立，也就是说，每一个JavaScript运行的“线程环境”都有一个独立的event loop,每个web worker也有一个独立的event loop
 * 【事件循环机制】每进行一次循环操作叫做tick，每一次tick的任务处理模型是比较复杂的，其关键步骤如下：
 * 1）执行一个宏任务（执行栈中没有就从事件队列中获取）
 * 2）执行过程中如果遇到微任务，将将它添到微任务队列
 * 3）宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
 * 4）当前宏任务执行完毕，开始检查渲染，然后GUI接管渲染
 * 5）渲染完毕后，JS线程继续接管，开始下一个宏任务(从事件队列中获取)
 * 
 * JS分为同步任务和异步任务
 * 同步任务都在主线程上执行，形成一个执行栈；
 * 主线程之外，消息线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件回调
 * 一旦执行执行栈中的所有同步任务执行完毕（JS引擎空闲时），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。
 * 
 * 宏任务：macrotask
 * 可以理解每次执行栈执行的函数就是一个宏任务（包括事件回调函数）
 * 浏览器为了能够使得JS内部macrotask与Dom任务能有序执行，会在一个macrotask执行结束后，下一个macrotask开始执行前，对页面重新渲染，流程如下：
 * 宏任务--渲染--宏任务。。。。
 * 包括：
 * 	script
 * 	setTimeout
 * 	setInterval
 * 	I/O
 * 	UI交互事件
 * 	postMessage
 * 	setImmediate(Node.js)
 * 
 * 微任务：microtask
 * 可以理解是在当前task执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。
 * 所以，它的响应速度相比task会更快，因为无需等渲染。
 * 即，在某个宏任务结束后，就会将在它执行期间产生的所有微任务都执行完毕。
 * 包含：
 * 	Promise.then
 * 	Object.observe
 * 	MutationObserver
 * 	process.nextTick(Node.js)
 * 
 */

